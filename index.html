<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="screen-orientation" content="landscape">
    <title>Piano Keyboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            background: #1a1a1a;
            touch-action: none;
        }

        #controls {
            background: #2a2a2a;
            padding: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            border-bottom: 2px solid #444;
        }

        .backend-button {
            background: #444;
            color: #fff;
            border: 2px solid #666;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
            min-width: 120px;
        }

        .backend-button:hover {
            background: #555;
        }

        .backend-button.active {
            background: #667eea;
            border-color: #667eea;
            font-weight: bold;
        }

        .backend-button.loading {
            background: #ff9800;
            border-color: #ff9800;
        }

        .backend-button.error {
            background: #f44336;
            border-color: #f44336;
        }

        .status-text {
            color: #aaa;
            font-size: 12px;
            margin-left: 10px;
        }

        #keyboard {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #piano {
            position: relative;
            display: flex;
            height: 80%;
            width: 95%;
        }

        .white-key {
            flex: 1;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #000;
            border-radius: 0 0 5px 5px;
            cursor: pointer;
            position: relative;
            transition: background 0.05s;
        }

        .white-key:active,
        .white-key.active {
            background: linear-gradient(to bottom, #d0d0d0 0%, #c0c0c0 100%);
        }

        .black-key {
            position: absolute;
            width: 6%;
            height: 60%;
            background: linear-gradient(to bottom, #2a2a2a 0%, #000000 100%);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            cursor: pointer;
            z-index: 10;
            transition: background 0.05s;
        }

        .black-key:active,
        .black-key.active {
            background: linear-gradient(to bottom, #4a4a4a 0%, #2a2a2a 100%);
        }

        /* Position black keys perfectly centered between white keys */
        .black-key[data-note="C#4"] { left: 7%; }
        .black-key[data-note="D#4"] { left: 17%; }
        .black-key[data-note="F#4"] { left: 37%; }
        .black-key[data-note="G#4"] { left: 47%; }
        .black-key[data-note="A#4"] { left: 57%; }
        .black-key[data-note="C#5"] { left: 77%; }
        .black-key[data-note="D#5"] { left: 87%; }

        @media (max-width: 768px) {
            #piano {
                width: 98%;
                height: 70%;
            }

            .black-key {
                width: 8%;
            }

            /* Adjust black key positions for 8% width (centered at same positions) */
            .black-key[data-note="C#4"] { left: 6%; }
            .black-key[data-note="D#4"] { left: 16%; }
            .black-key[data-note="F#4"] { left: 36%; }
            .black-key[data-note="G#4"] { left: 46%; }
            .black-key[data-note="A#4"] { left: 56%; }
            .black-key[data-note="C#5"] { left: 76%; }
            .black-key[data-note="D#5"] { left: 86%; }

            .backend-button {
                font-size: 12px;
                padding: 6px 12px;
                min-width: 100px;
            }
        }

        @media (orientation: portrait) {
            #piano {
                width: 90%;
                height: 40%;
            }
        }

        /* Start overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            cursor: pointer;
        }

        #start-overlay.hidden {
            display: none;
        }

        #start-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 24px;
            padding: 20px 40px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        #start-button:hover {
            transform: scale(1.05);
        }

        #start-button:active {
            transform: scale(0.95);
        }

        #start-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="start-overlay">
        <button id="start-button">Start Playing</button>
    </div>

    <div id="controls">
        <button class="backend-button" data-backend="A">Backend A: Oscillators</button>
        <button class="backend-button" data-backend="B">Backend B: Samples</button>
        <button class="backend-button" data-backend="D">Backend D: Tone.js</button>
        <span class="status-text" id="status-text">Select a backend</span>
    </div>

    <div id="keyboard">
        <div id="piano"></div>
    </div>

    <!-- Load Tone.js from CDN for Backend D -->
    <script src="https://cdn.jsdelivr.net/npm/tone@14.8.49/build/Tone.min.js"></script>

    <script>
        // Note frequencies (C4 to E5)
        const noteFrequencies = {
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
            'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
            'E5': 659.25
        };

        // White and black keys
        const whiteKeys = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5'];
        const blackKeys = ['C#4', 'D#4', 'F#4', 'G#4', 'A#4', 'C#5', 'D#5'];
        const allNotes = Object.keys(noteFrequencies);

        // Minimum note duration in milliseconds
        const MIN_NOTE_DURATION = 400;

        // Global state
        let currentBackend = null;
        let audioReady = false;

        // ====================================================================
        // BACKEND A: Web Audio API with Oscillators (Original Implementation)
        // ====================================================================
        const BackendA = {
            name: 'Oscillators',
            audioContext: null,
            activeOscillators: new Map(),
            noteStartTimes: new Map(),
            pendingStops: new Map(),

            async init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Unlock audio for iOS Safari
                const unlockOscillator = this.audioContext.createOscillator();
                const unlockGain = this.audioContext.createGain();
                unlockGain.gain.setValueAtTime(0.001, this.audioContext.currentTime);
                unlockGain.gain.linearRampToValueAtTime(0.0001, this.audioContext.currentTime + 0.2);
                unlockOscillator.frequency.setValueAtTime(440, this.audioContext.currentTime);
                unlockOscillator.connect(unlockGain);
                unlockGain.connect(this.audioContext.destination);
                unlockOscillator.start(this.audioContext.currentTime);
                unlockOscillator.stop(this.audioContext.currentTime + 0.2);

                // Wait for audio context to be running
                await new Promise((resolve, reject) => {
                    const checkRunning = () => {
                        if (this.audioContext.state === 'running') {
                            resolve();
                        } else if (this.audioContext.state === 'suspended') {
                            this.audioContext.resume().then(() => {
                                setTimeout(() => {
                                    if (this.audioContext.state === 'running') {
                                        resolve();
                                    } else {
                                        reject(new Error('Audio context failed to start'));
                                    }
                                }, 100);
                            }).catch(reject);
                        } else {
                            reject(new Error('Audio context in unexpected state'));
                        }
                    };
                    setTimeout(checkRunning, 100);
                });
            },

            playNote(note) {
                if (!this.audioContext || this.audioContext.state !== 'running') return;

                // Cancel any pending stop timeout
                if (this.pendingStops.has(note)) {
                    clearTimeout(this.pendingStops.get(note));
                    this.pendingStops.delete(note);
                }

                // Stop existing note if playing
                if (this.activeOscillators.has(note)) {
                    this.stopNoteImmediately(note);
                }

                const frequency = noteFrequencies[note];
                const currentTime = this.audioContext.currentTime;

                // Create master gain node
                const masterGain = this.audioContext.createGain();
                masterGain.gain.setValueAtTime(0.0001, currentTime);
                masterGain.gain.linearRampToValueAtTime(0.3, currentTime + 0.005);
                masterGain.gain.exponentialRampToValueAtTime(0.2, currentTime + 0.1);
                masterGain.gain.exponentialRampToValueAtTime(0.05, currentTime + 2);

                // Create multiple oscillators for harmonics
                const oscillators = [];

                // Fundamental
                const osc1 = this.audioContext.createOscillator();
                osc1.type = 'triangle';
                osc1.frequency.setValueAtTime(frequency, currentTime);
                const gain1 = this.audioContext.createGain();
                gain1.gain.setValueAtTime(0.4, currentTime);
                osc1.connect(gain1);
                gain1.connect(masterGain);
                oscillators.push(osc1);

                // Second harmonic
                const osc2 = this.audioContext.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.setValueAtTime(frequency * 2, currentTime);
                const gain2 = this.audioContext.createGain();
                gain2.gain.setValueAtTime(0.15, currentTime);
                osc2.connect(gain2);
                gain2.connect(masterGain);
                oscillators.push(osc2);

                // Third harmonic
                const osc3 = this.audioContext.createOscillator();
                osc3.type = 'sine';
                osc3.frequency.setValueAtTime(frequency * 3, currentTime);
                const gain3 = this.audioContext.createGain();
                gain3.gain.setValueAtTime(0.08, currentTime);
                osc3.connect(gain3);
                gain3.connect(masterGain);
                oscillators.push(osc3);

                // Fourth harmonic
                const osc4 = this.audioContext.createOscillator();
                osc4.type = 'sine';
                osc4.frequency.setValueAtTime(frequency * 4, currentTime);
                const gain4 = this.audioContext.createGain();
                gain4.gain.setValueAtTime(0.04, currentTime);
                osc4.connect(gain4);
                gain4.connect(masterGain);
                oscillators.push(osc4);

                masterGain.connect(this.audioContext.destination);

                // Start all oscillators
                oscillators.forEach(osc => osc.start(currentTime));

                this.activeOscillators.set(note, { oscillators, gainNode: masterGain });
                this.noteStartTimes.set(note, Date.now());
            },

            stopNote(note) {
                if (this.activeOscillators.has(note)) {
                    const noteStartTime = this.noteStartTimes.get(note);
                    const elapsed = Date.now() - noteStartTime;
                    const remainingTime = MIN_NOTE_DURATION - elapsed;

                    if (remainingTime > 0) {
                        const timeoutId = setTimeout(() => {
                            this.stopNoteImmediately(note);
                            this.pendingStops.delete(note);
                        }, remainingTime);
                        this.pendingStops.set(note, timeoutId);
                    } else {
                        this.stopNoteImmediately(note);
                    }
                }
            },

            stopNoteImmediately(note) {
                if (this.activeOscillators.has(note)) {
                    const { oscillators, gainNode } = this.activeOscillators.get(note);
                    const currentTime = this.audioContext.currentTime;

                    try {
                        gainNode.gain.cancelScheduledValues(currentTime);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.0001, currentTime + 0.3);
                        oscillators.forEach(osc => {
                            try {
                                osc.stop(currentTime + 0.3);
                            } catch (e) {}
                        });
                    } catch (e) {
                        console.error('Error stopping note:', e);
                    }

                    this.activeOscillators.delete(note);
                    this.noteStartTimes.delete(note);
                }
            },

            cleanup() {
                // Stop all playing notes
                this.activeOscillators.forEach((_, note) => this.stopNoteImmediately(note));
                this.pendingStops.forEach(timeoutId => clearTimeout(timeoutId));
                this.pendingStops.clear();

                // Close audio context
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }
        };

        // ====================================================================
        // BACKEND B: Web Audio API with AudioBuffers (Samples)
        // ====================================================================
        const BackendB = {
            name: 'Samples (AudioBuffer)',
            audioContext: null,
            buffers: new Map(),
            activeSources: new Map(),
            noteStartTimes: new Map(),
            pendingStops: new Map(),

            async init() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Unlock audio
                const unlockOscillator = this.audioContext.createOscillator();
                const unlockGain = this.audioContext.createGain();
                unlockGain.gain.setValueAtTime(0.001, this.audioContext.currentTime);
                unlockOscillator.connect(unlockGain);
                unlockGain.connect(this.audioContext.destination);
                unlockOscillator.start(this.audioContext.currentTime);
                unlockOscillator.stop(this.audioContext.currentTime + 0.1);

                await this.audioContext.resume();

                // Load all note samples
                await this.loadSamples();

                if (this.audioContext.state !== 'running') {
                    throw new Error('Audio context not running');
                }
            },

            async loadSamples() {
                // For testing: generate samples using oscillators if files don't exist
                // In production, replace with actual sample loading
                const loadPromises = allNotes.map(async (note) => {
                    try {
                        // Try to load from sounds/ directory
                        const response = await fetch(`sounds/${note}.mp3`);
                        if (response.ok) {
                            const arrayBuffer = await response.arrayBuffer();
                            const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                            this.buffers.set(note, audioBuffer);
                        } else {
                            // Fallback: generate a simple buffer using oscillator
                            this.buffers.set(note, this.generateSampleBuffer(note));
                        }
                    } catch (error) {
                        // Fallback: generate a simple buffer
                        this.buffers.set(note, this.generateSampleBuffer(note));
                    }
                });

                await Promise.all(loadPromises);
            },

            generateSampleBuffer(note) {
                // Generate a 2-second piano-like sample
                const duration = 2;
                const sampleRate = this.audioContext.sampleRate;
                const buffer = this.audioContext.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                const frequency = noteFrequencies[note];

                for (let i = 0; i < buffer.length; i++) {
                    const t = i / sampleRate;
                    const decay = Math.exp(-t * 2); // Exponential decay

                    // Mix fundamental and harmonics
                    let sample = 0;
                    sample += 0.4 * Math.sin(2 * Math.PI * frequency * t);
                    sample += 0.15 * Math.sin(2 * Math.PI * frequency * 2 * t);
                    sample += 0.08 * Math.sin(2 * Math.PI * frequency * 3 * t);
                    sample += 0.04 * Math.sin(2 * Math.PI * frequency * 4 * t);

                    data[i] = sample * decay;
                }

                return buffer;
            },

            playNote(note) {
                if (!this.audioContext || !this.buffers.has(note)) return;

                // Cancel pending stops
                if (this.pendingStops.has(note)) {
                    clearTimeout(this.pendingStops.get(note));
                    this.pendingStops.delete(note);
                }

                // Stop existing note
                if (this.activeSources.has(note)) {
                    this.stopNoteImmediately(note);
                }

                const source = this.audioContext.createBufferSource();
                const gainNode = this.audioContext.createGain();

                source.buffer = this.buffers.get(note);
                source.connect(gainNode);
                gainNode.connect(this.audioContext.destination);

                // Set initial volume
                gainNode.gain.setValueAtTime(0.6, this.audioContext.currentTime);

                source.start(0);

                this.activeSources.set(note, { source, gainNode });
                this.noteStartTimes.set(note, Date.now());
            },

            stopNote(note) {
                if (this.activeSources.has(note)) {
                    const noteStartTime = this.noteStartTimes.get(note);
                    const elapsed = Date.now() - noteStartTime;
                    const remainingTime = MIN_NOTE_DURATION - elapsed;

                    if (remainingTime > 0) {
                        const timeoutId = setTimeout(() => {
                            this.stopNoteImmediately(note);
                            this.pendingStops.delete(note);
                        }, remainingTime);
                        this.pendingStops.set(note, timeoutId);
                    } else {
                        this.stopNoteImmediately(note);
                    }
                }
            },

            stopNoteImmediately(note) {
                if (this.activeSources.has(note)) {
                    const { source, gainNode } = this.activeSources.get(note);
                    const currentTime = this.audioContext.currentTime;

                    try {
                        gainNode.gain.cancelScheduledValues(currentTime);
                        gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
                        gainNode.gain.linearRampToValueAtTime(0, currentTime + 0.3);
                        source.stop(currentTime + 0.3);
                    } catch (e) {
                        console.error('Error stopping note:', e);
                    }

                    this.activeSources.delete(note);
                    this.noteStartTimes.delete(note);
                }
            },

            cleanup() {
                this.activeSources.forEach((_, note) => this.stopNoteImmediately(note));
                this.pendingStops.forEach(timeoutId => clearTimeout(timeoutId));
                this.pendingStops.clear();
                this.buffers.clear();

                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
            }
        };

        // ====================================================================
        // BACKEND D: Tone.js Library
        // ====================================================================
        const BackendD = {
            name: 'Tone.js',
            sampler: null,
            activeSources: new Map(),
            noteStartTimes: new Map(),
            pendingStops: new Map(),

            async init() {
                if (typeof Tone === 'undefined') {
                    throw new Error('Tone.js library not loaded');
                }

                // Start Tone.js audio context
                await Tone.start();

                // Create a sampler with generated samples
                // In production, you'd use real piano samples
                this.sampler = new Tone.Sampler({
                    urls: this.generateSampleUrls(),
                    baseUrl: '',
                    onload: () => {
                        console.log('Tone.js sampler loaded');
                    },
                    release: 1,
                    attack: 0.005,
                }).toDestination();

                // Since we're using data URLs, wait a bit for them to process
                await new Promise(resolve => setTimeout(resolve, 100));
            },

            generateSampleUrls() {
                // Generate very simple sine wave data URLs for testing
                // In production, replace with actual piano sample URLs
                const urls = {};

                allNotes.forEach(note => {
                    // Use a minimal silent data URL as placeholder
                    // Tone.js will synthesize these notes
                    urls[note] = this.createSineWaveDataUrl(noteFrequencies[note]);
                });

                return urls;
            },

            createSineWaveDataUrl(frequency) {
                // Create a minimal WAV file with a piano-like tone
                const sampleRate = 44100;
                const duration = 2;
                const numSamples = sampleRate * duration;

                // WAV header + data
                const buffer = new ArrayBuffer(44 + numSamples * 2);
                const view = new DataView(buffer);

                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };

                writeString(0, 'RIFF');
                view.setUint32(4, 36 + numSamples * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, numSamples * 2, true);

                // Generate samples
                let offset = 44;
                for (let i = 0; i < numSamples; i++) {
                    const t = i / sampleRate;
                    const decay = Math.exp(-t * 2);

                    let sample = 0;
                    sample += 0.4 * Math.sin(2 * Math.PI * frequency * t);
                    sample += 0.15 * Math.sin(2 * Math.PI * frequency * 2 * t);
                    sample += 0.08 * Math.sin(2 * Math.PI * frequency * 3 * t);

                    const value = Math.max(-1, Math.min(1, sample * decay));
                    view.setInt16(offset, value * 32767, true);
                    offset += 2;
                }

                const blob = new Blob([buffer], { type: 'audio/wav' });
                return URL.createObjectURL(blob);
            },

            playNote(note) {
                if (!this.sampler) return;

                // Cancel pending stops
                if (this.pendingStops.has(note)) {
                    clearTimeout(this.pendingStops.get(note));
                    this.pendingStops.delete(note);
                }

                // Trigger the note with Tone.js
                this.sampler.triggerAttack(note, Tone.now(), 0.8);
                this.noteStartTimes.set(note, Date.now());
                this.activeSources.set(note, true);
            },

            stopNote(note) {
                if (this.activeSources.has(note)) {
                    const noteStartTime = this.noteStartTimes.get(note);
                    const elapsed = Date.now() - noteStartTime;
                    const remainingTime = MIN_NOTE_DURATION - elapsed;

                    if (remainingTime > 0) {
                        const timeoutId = setTimeout(() => {
                            this.stopNoteImmediately(note);
                            this.pendingStops.delete(note);
                        }, remainingTime);
                        this.pendingStops.set(note, timeoutId);
                    } else {
                        this.stopNoteImmediately(note);
                    }
                }
            },

            stopNoteImmediately(note) {
                if (this.activeSources.has(note) && this.sampler) {
                    try {
                        this.sampler.triggerRelease(note, Tone.now());
                    } catch (e) {
                        console.error('Error releasing note:', e);
                    }
                    this.activeSources.delete(note);
                    this.noteStartTimes.delete(note);
                }
            },

            cleanup() {
                if (this.sampler) {
                    this.sampler.releaseAll();
                    this.sampler.dispose();
                    this.sampler = null;
                }
                this.pendingStops.forEach(timeoutId => clearTimeout(timeoutId));
                this.pendingStops.clear();
                this.activeSources.clear();
                this.noteStartTimes.clear();
            }
        };

        // ====================================================================
        // Backend Management
        // ====================================================================
        const backends = {
            'A': BackendA,
            'B': BackendB,
            'D': BackendD
        };

        async function switchBackend(backendId) {
            const backend = backends[backendId];
            if (!backend) return;

            const button = document.querySelector(`[data-backend="${backendId}"]`);
            const statusText = document.getElementById('status-text');

            // Clear all button states
            document.querySelectorAll('.backend-button').forEach(btn => {
                btn.classList.remove('active', 'loading', 'error');
            });

            button.classList.add('loading');
            statusText.textContent = `Loading ${backend.name}...`;

            try {
                // Cleanup old backend
                if (currentBackend) {
                    currentBackend.cleanup();
                }

                // Initialize new backend
                await backend.init();

                currentBackend = backend;
                audioReady = true;

                button.classList.remove('loading');
                button.classList.add('active');
                statusText.textContent = `${backend.name} ready`;

                console.log(`Switched to backend ${backendId}: ${backend.name}`);
            } catch (error) {
                console.error(`Failed to initialize backend ${backendId}:`, error);
                button.classList.remove('loading');
                button.classList.add('error');
                statusText.textContent = `Error: ${error.message}`;
                audioReady = false;
                currentBackend = null;
            }
        }

        function playNote(note) {
            if (!audioReady || !currentBackend) {
                console.log('Audio not ready or no backend selected');
                return;
            }
            currentBackend.playNote(note);
        }

        function stopNote(note) {
            if (currentBackend) {
                currentBackend.stopNote(note);
            }
        }

        // ====================================================================
        // Keyboard UI
        // ====================================================================
        function createKeyboard() {
            const piano = document.getElementById('piano');

            // Create white keys
            whiteKeys.forEach(note => {
                const key = document.createElement('div');
                key.className = 'white-key';
                key.dataset.note = note;
                piano.appendChild(key);
            });

            // Create black keys
            blackKeys.forEach(note => {
                const key = document.createElement('div');
                key.className = 'black-key';
                key.dataset.note = note;
                piano.appendChild(key);
            });

            // Add event listeners
            const allKeys = document.querySelectorAll('.white-key, .black-key');
            allKeys.forEach(key => {
                const note = key.dataset.note;

                // Mouse events
                key.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    key.classList.add('active');
                    playNote(note);
                });

                key.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });

                key.addEventListener('mouseleave', (e) => {
                    key.classList.remove('active');
                    stopNote(note);
                });

                // Touch events
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    key.classList.add('active');
                    playNote(note);
                });

                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });

                key.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });
            });
        }

        function lockOrientation() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {});
            }
        }

        // ====================================================================
        // Initialize
        // ====================================================================
        document.addEventListener('DOMContentLoaded', () => {
            createKeyboard();
            lockOrientation();

            // Handle backend selection buttons
            document.querySelectorAll('.backend-button').forEach(button => {
                button.addEventListener('click', () => {
                    const backendId = button.dataset.backend;
                    switchBackend(backendId);
                });
            });

            // Handle start button
            const startOverlay = document.getElementById('start-overlay');
            const startButton = document.getElementById('start-button');

            const handleStart = () => {
                startButton.textContent = 'Starting...';
                startButton.disabled = true;

                setTimeout(() => {
                    startOverlay.classList.add('hidden');
                    // Auto-select Backend A as default
                    switchBackend('A');
                }, 300);
            };

            startButton.addEventListener('click', handleStart);
            startButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleStart();
            });

            startOverlay.addEventListener('click', (e) => {
                if (e.target === startOverlay) {
                    handleStart();
                }
            });
        });

        // Prevent default touch behavior
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
