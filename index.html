<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="screen-orientation" content="landscape">
    <title>Piano Keyboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #1a1a1a;
            touch-action: none;
        }

        #keyboard {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #piano {
            position: relative;
            display: flex;
            height: 80%;
            width: 95%;
        }

        .white-key {
            flex: 1;
            height: 100%;
            background: linear-gradient(to bottom, #ffffff 0%, #f0f0f0 100%);
            border: 2px solid #000;
            border-radius: 0 0 5px 5px;
            cursor: pointer;
            position: relative;
            transition: background 0.05s;
        }

        .white-key:active,
        .white-key.active {
            background: linear-gradient(to bottom, #d0d0d0 0%, #c0c0c0 100%);
        }

        .black-key {
            position: absolute;
            width: 6%;
            height: 60%;
            background: linear-gradient(to bottom, #2a2a2a 0%, #000000 100%);
            border: 1px solid #000;
            border-radius: 0 0 3px 3px;
            cursor: pointer;
            z-index: 10;
            transition: background 0.05s;
        }

        .black-key:active,
        .black-key.active {
            background: linear-gradient(to bottom, #4a4a4a 0%, #2a2a2a 100%);
        }

        /* Position black keys perfectly centered between white keys */
        .black-key[data-note="C#4"] { left: 7%; }
        .black-key[data-note="D#4"] { left: 17%; }
        .black-key[data-note="F#4"] { left: 37%; }
        .black-key[data-note="G#4"] { left: 47%; }
        .black-key[data-note="A#4"] { left: 57%; }
        .black-key[data-note="C#5"] { left: 77%; }
        .black-key[data-note="D#5"] { left: 87%; }

        @media (max-width: 768px) {
            #piano {
                width: 98%;
                height: 70%;
            }

            .black-key {
                width: 8%;
            }

            /* Adjust black key positions for 8% width (centered at same positions) */
            .black-key[data-note="C#4"] { left: 6%; }
            .black-key[data-note="D#4"] { left: 16%; }
            .black-key[data-note="F#4"] { left: 36%; }
            .black-key[data-note="G#4"] { left: 46%; }
            .black-key[data-note="A#4"] { left: 56%; }
            .black-key[data-note="C#5"] { left: 76%; }
            .black-key[data-note="D#5"] { left: 86%; }
        }

        @media (orientation: portrait) {
            #piano {
                width: 90%;
                height: 40%;
            }
        }

        /* Start overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            cursor: pointer;
        }

        #start-overlay.hidden {
            display: none;
        }

        #start-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            font-size: 24px;
            padding: 20px 40px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }

        #start-button:hover {
            transform: scale(1.05);
        }

        #start-button:active {
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="start-overlay">
        <button id="start-button">Start Playing</button>
    </div>

    <div id="keyboard">
        <div id="piano"></div>
    </div>

    <script>
        // Note frequencies (C4 to E5)
        const noteFrequencies = {
            'C4': 261.63, 'C#4': 277.18, 'D4': 293.66, 'D#4': 311.13,
            'E4': 329.63, 'F4': 349.23, 'F#4': 369.99, 'G4': 392.00,
            'G#4': 415.30, 'A4': 440.00, 'A#4': 466.16, 'B4': 493.88,
            'C5': 523.25, 'C#5': 554.37, 'D5': 587.33, 'D#5': 622.25,
            'E5': 659.25
        };

        // White and black keys
        const whiteKeys = ['C4', 'D4', 'E4', 'F4', 'G4', 'A4', 'B4', 'C5', 'D5', 'E5'];
        const blackKeys = ['C#4', 'D#4', 'F#4', 'G#4', 'A#4', 'C#5', 'D#5'];

        // Minimum note duration in milliseconds (adjust this value to your preference)
        const MIN_NOTE_DURATION = 400;

        // Audio context
        let audioContext;
        const activeOscillators = new Map();
        const noteStartTimes = new Map();
        const pendingStops = new Map();
        let audioReady = false;

        // Initialize audio context - called from start button
        function initAudioContext() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Unlock audio for iOS Safari - use both buffer and oscillator methods
            // Method 1: Silent buffer
            const buffer = audioContext.createBuffer(1, 1, 22050);
            const bufferSource = audioContext.createBufferSource();
            bufferSource.buffer = buffer;
            bufferSource.connect(audioContext.destination);
            bufferSource.start(0);

            // Method 2: Silent oscillator (more reliable on iOS)
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0.00001, audioContext.currentTime);
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + 0.01);

            // Resume context if suspended (important for iOS)
            if (audioContext.state === 'suspended') {
                audioContext.resume().then(() => {
                    console.log('Audio context resumed');
                    audioReady = true;
                });
            } else {
                audioReady = true;
            }
        }

        // Play note with piano-like sound
        function playNote(note) {
            if (!audioReady || !audioContext) {
                return;
            }

            // Cancel any pending stop timeout
            if (pendingStops.has(note)) {
                clearTimeout(pendingStops.get(note));
                pendingStops.delete(note);
            }

            // Stop existing note if playing
            if (activeOscillators.has(note)) {
                stopNoteImmediately(note);
            }

            const frequency = noteFrequencies[note];
            const currentTime = audioContext.currentTime;

            // Create master gain node
            const masterGain = audioContext.createGain();

            // Piano-like ADSR envelope
            masterGain.gain.setValueAtTime(0, currentTime);
            masterGain.gain.linearRampToValueAtTime(0.3, currentTime + 0.005); // Quick attack
            masterGain.gain.exponentialRampToValueAtTime(0.2, currentTime + 0.1); // Decay
            masterGain.gain.exponentialRampToValueAtTime(0.05, currentTime + 2); // Sustain/release

            // Create multiple oscillators for harmonics (piano-like timbre)
            const oscillators = [];

            // Fundamental
            const osc1 = audioContext.createOscillator();
            osc1.type = 'triangle';
            osc1.frequency.setValueAtTime(frequency, currentTime);
            const gain1 = audioContext.createGain();
            gain1.gain.setValueAtTime(0.4, currentTime);
            osc1.connect(gain1);
            gain1.connect(masterGain);
            oscillators.push(osc1);

            // Second harmonic
            const osc2 = audioContext.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.setValueAtTime(frequency * 2, currentTime);
            const gain2 = audioContext.createGain();
            gain2.gain.setValueAtTime(0.15, currentTime);
            osc2.connect(gain2);
            gain2.connect(masterGain);
            oscillators.push(osc2);

            // Third harmonic
            const osc3 = audioContext.createOscillator();
            osc3.type = 'sine';
            osc3.frequency.setValueAtTime(frequency * 3, currentTime);
            const gain3 = audioContext.createGain();
            gain3.gain.setValueAtTime(0.08, currentTime);
            osc3.connect(gain3);
            gain3.connect(masterGain);
            oscillators.push(osc3);

            // Fourth harmonic
            const osc4 = audioContext.createOscillator();
            osc4.type = 'sine';
            osc4.frequency.setValueAtTime(frequency * 4, currentTime);
            const gain4 = audioContext.createGain();
            gain4.gain.setValueAtTime(0.04, currentTime);
            osc4.connect(gain4);
            gain4.connect(masterGain);
            oscillators.push(osc4);

            masterGain.connect(audioContext.destination);

            // Start all oscillators
            oscillators.forEach(osc => osc.start(currentTime));

            activeOscillators.set(note, { oscillators, gainNode: masterGain });
            noteStartTimes.set(note, Date.now());
        }

        // Stop note
        function stopNote(note) {
            if (activeOscillators.has(note)) {
                const noteStartTime = noteStartTimes.get(note);
                const elapsed = Date.now() - noteStartTime;
                const remainingTime = MIN_NOTE_DURATION - elapsed;

                if (remainingTime > 0) {
                    // Schedule stop after minimum duration
                    const timeoutId = setTimeout(() => {
                        stopNoteImmediately(note);
                        pendingStops.delete(note);
                    }, remainingTime);
                    pendingStops.set(note, timeoutId);
                } else {
                    // Minimum duration already elapsed, stop immediately
                    stopNoteImmediately(note);
                }
            }
        }

        // Actually stop the note
        function stopNoteImmediately(note) {
            if (activeOscillators.has(note)) {
                const { oscillators, gainNode } = activeOscillators.get(note);

                if (!audioContext) {
                    activeOscillators.delete(note);
                    noteStartTimes.delete(note);
                    return;
                }

                const currentTime = audioContext.currentTime;

                try {
                    gainNode.gain.cancelScheduledValues(currentTime);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, currentTime + 0.3);
                    oscillators.forEach(osc => osc.stop(currentTime + 0.3));
                } catch (e) {
                    // If stopping fails, just clean up the tracking
                    console.error('Error stopping note:', e);
                }

                activeOscillators.delete(note);
                noteStartTimes.delete(note);
            }
        }

        // Create keyboard
        function createKeyboard() {
            const piano = document.getElementById('piano');

            // Create white keys
            whiteKeys.forEach(note => {
                const key = document.createElement('div');
                key.className = 'white-key';
                key.dataset.note = note;
                piano.appendChild(key);
            });

            // Create black keys
            blackKeys.forEach(note => {
                const key = document.createElement('div');
                key.className = 'black-key';
                key.dataset.note = note;
                piano.appendChild(key);
            });

            // Add event listeners
            const allKeys = document.querySelectorAll('.white-key, .black-key');
            allKeys.forEach(key => {
                const note = key.dataset.note;

                // Mouse events
                key.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    key.classList.add('active');
                    playNote(note);
                });

                key.addEventListener('mouseup', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });

                key.addEventListener('mouseleave', (e) => {
                    key.classList.remove('active');
                    stopNote(note);
                });

                // Touch events
                key.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    key.classList.add('active');
                    playNote(note);
                });

                key.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });

                key.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    key.classList.remove('active');
                    stopNote(note);
                });
            });
        }

        // Lock screen orientation to landscape on mobile
        function lockOrientation() {
            if (screen.orientation && screen.orientation.lock) {
                screen.orientation.lock('landscape').catch(() => {
                    // Orientation lock might fail, that's okay
                });
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            createKeyboard();
            lockOrientation();

            // Handle start button
            const startOverlay = document.getElementById('start-overlay');
            const startButton = document.getElementById('start-button');

            const handleStart = () => {
                initAudioContext();
                startOverlay.classList.add('hidden');
            };

            // Handle both click and touch for iOS compatibility
            startButton.addEventListener('click', handleStart);
            startButton.addEventListener('touchend', (e) => {
                e.preventDefault();
                handleStart();
            });

            // Also allow clicking anywhere on the overlay
            startOverlay.addEventListener('click', (e) => {
                if (e.target === startOverlay) {
                    handleStart();
                }
            });
        });

        // Prevent default touch behavior
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
